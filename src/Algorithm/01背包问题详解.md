# 01背包问题详解
01 背包问题的题目大同小异，一般都是：

有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 c[i]，价值是 w[i]。求解将哪些物品装入背包可时价值总和最大。

## 基本思路
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即 f[i][v] 表示前 i 件物品恰好放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程是：

f[i][v] = max{f[i - 1][v], f[i - 1][v - c[i]] + w[i]}

若只考虑第 i 件物品的策略（放或不放），那么就可以转化为一个只牵扯到前 i-1 件物品的问题。

如果不放第 i 件物品，那么问题就转化为“前 i-1 件物品放入容量为 v 的背包中”，价值为 f[i - 1][v]；

如果放第 i 件物品，那么问题就转化为“前 i-1 件物品放入剩下的容量为 v-c[i] 的背包中”，此时能获得的最大价值就是 f[i - 1][v - c[i]] 再加上通过放入第 i件物品获得的价值 w[i]。

## 初始化细节问题
我们看到的求最优解的背包问题题目中，事实上有两种不太相同的写法。

有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。

一种区别这两种问法的实现方法是在初始化的时候有所不同。

如果是第一种问法，要求恰好装满背包，那么在初始化时除了 f[0] 为 0 其它 f[1...V] 均设为 -∞，这样就可以保证最终得到的 f[N] 是一种恰好装满背包的最优解。

如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 f[0...V] 全部设为 0。

为什么呢？可以这样理解：初始化的 f 数组事实上就是在没有任何物品可以放入背包时的合法状态。

如果要求背包恰好装满，那么此时只有容量为 0 的背包可能被价值为 0 的 nothing “恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是 -∞ 了。

如果背包并非必须被装满，那么任何容量的背包都有一个合法解 “什么都不装”，这个解的价值为 0，所以初始化时状态的值也就全部为 0 了。

## 优化空间复杂度
以上方法的时间和空间复杂度均为 O(VN)，其中时间复杂度已经不能再优化了，但空间复杂度却可以优化到 O(V)。

先考虑上面讲的基本思路如何实现，肯定是有一个主循环 i=1...N，每次算出来二维数组 f[i][0...V] 所有值。

那么，如果只用一个数组 f[0...V]，能不能保证第 i 次循环结束后 f[v] 中表示的就是我们定义的状态 f[i][v] 呢？

f[i][v] 是由 f[i - 1][v] 和 f[i - 1][v - c[i]] 两个子问题递推而来，能否保证在推 f[i][v] 时（也即在第 i 次主循环中推 f[v] 时）能够得到 f[i - 1][v] 和 f[i - 1][v - c[i]] 的值呢？

事实上，这要求在每次主循环中我们以 v=V...0 的顺序推 f[v]，这样才能保证推 f[v] 时 f[v - c[i]] 保存的是状态 f[i - 1][v - c[i]] 的值。伪代码如下：

```java
for i = 1...N
  for v = V...0
    f[v] = max{f[v], f[v - c[i]] + w[i]};
```

其中的 f[v] = max{f[v], f[v - c[i]]} 一句恰就相当于我们的转移方程 f[i][v] = max{f[i - 1][v], f[i - 1][v - c[i]]}，因为现在的 f[v - c[i]]就相当于原来的 f[i - 1][v - c[i]]。

如果将 v 的循环顺序从上面的逆序改成顺序的话，那么则成了 f[i][v] 由 f[i][v - c[i]] 推知，与本题意不符

抽象出一个使用一维数组解 01 背包问题的伪代码：（两个参数 cost、weight 分别表明这件物品的费用和价值）

```java
procedure ZeroOnePack(cost, weight)
  for v = V...cost                          // 费用为 cost 的物品不会影响状态 f[0...cost-1]
    f[v] = max{f[v], f[v - cost] + weight}
```

可以使用一维 DP 是因为每一次计算 dp[i][v] 只用到了上一层的数据 dp[i - 1][v], dp[i - 1][v - c[i]]

所以用一个一维数组就可以记录每一层的信息，进入下一层的时候就在上一层的基础上加以更新；

内层循环的逆序保证了对于 dp[v]，它要调用的 dp[v - c[i]] 一定是第 i 层循环还没有更新过的，换言之，dp[v - c[i]] 只有可能是第 i-1 层存储的数据。

如果是顺序，比如 v 从 20-90,那么在算 v = 40 的时候，可能会出现 dp[40] 由 dp[40 - 20] 推出，而 dp[20] 在本轮之前已经被更新过了，就无法记录上一层的信息








































